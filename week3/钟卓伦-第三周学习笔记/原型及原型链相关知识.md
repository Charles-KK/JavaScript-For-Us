## 原型与原型链
* 所有函数都有一个特别的属性:
  * `prototype` : 显式原型属性
      1.1). 每个函数都有一个prototype属性, 它默认指向一个{}(原型对象)
      1.2). 原型对象中有一个属性constructor, 它指向函数对象
      1.3). Object的原型
    * Object实例对象的方法都定义在Object的原型对象中
    * Object的原型对象的原型为null(没有父对象)
* 所有实例对象都有一个特别的属性:
  * `__proto__` : 隐式原型属性
    *  隐式原型的值为其对应的显示原型的值
* 显式原型与隐式原型的关系
  * 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象
  * 实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值
  * 原型对象即为当前实例对象的父对象

![2196534b520bd5b132ecb30e3fc475e7.png](evernotecid://CEB7F35F-CF96-4521-B417-9D3060DC64F6/appyinxiangcom/25551795/ENResource/p16)


* 原型链
  * 所有的实例对象都有__proto__属性, 它指向的就是原型对象
  * 这样通过__proto__属性就形成了一个链的结构---->原型链
  * 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找
  * 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作
  * 查找一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找
![732ea1794d43896bca5df00f7409a9bc.png](evernotecid://CEB7F35F-CF96-4521-B417-9D3060DC64F6/appyinxiangcom/25551795/ENResource/p18)

![d63a95e6f5c7c68f1d63c69e5b891108.png](evernotecid://CEB7F35F-CF96-4521-B417-9D3060DC64F6/appyinxiangcom/25551795/ENResource/p17)
* 构造函数/原型/实例对象的关系（图解）
```
var o1 = new Object();
var o2 = {};
```
![1366f38585731557fe9cfa003bf3b310.png](evernotecid://CEB7F35F-CF96-4521-B417-9D3060DC64F6/appyinxiangcom/25551795/ENResource/p22)

* 原型继承
    * 构造函数的实例对象自动拥有构造函数原型对象的属性(方法)
    * 利用的就是原型链
* 原型属性问题
    * 读取对象的属性值时, 会自动到原型对象中查找
    * 设置对象的属性值时, 不会查找原型链, 如果当前对象中没有此属性, 
直接添加此属性并设置其值
* 学习jQuery引发的思考

## 上下文环境对象与上下文环境栈
* 变量提升与函数提升
  * 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)
  * 函数提升: 在函数定义语句之前, 就执行该函数
  * 简单原因: js引擎在准备执行全局代码和函数体之前, 都会做'预处理'(收集变量/函数)
* 理解
  * 环境对象: 由js引擎自动创建的对象, 包含对应作用域中的变量属性
  * 环境对象栈: 用来管理产生的多个环境对象
* 分类:
  * 全局: window
  * 函数: 对程序员来说是透明的
* 生命周期
  * 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡
  * 函数 : 调用函数时产生, 函数执行完时死亡
* 包含哪些属性:
  * 全局 : 
    * 用var定义的全局变量  ==>undefined
    * 使用function声明的函数   ===>function
    * this   ===>window
  * 函数
    * 用var定义的局部变量  ==>undefined
    * 使用function声明的函数   ===>function
    * this   ===> 调用函数的对象, 如果没有指定就是window 
    * 形参变量   ===>对应实参值
    * arguments ===>实参列表的伪数组
* 上下文对象创建和初始化的过程
  * 全局:
    * 在全局代码执行前最先创建一个全局上下文对象(window)
    * 收集一些全局变量, 并初始化
    * 将这些变量设置为上下文对象的属性
  * 函数:
    * 在调用函数时, 在执行函数体之前先创建一个函数上下文对象
    * 收集一些局部变量, 并初始化
    * 将这些变量设置为上下文对象的属性
    
## 作用域与作用域链
* 理解:
  * 作用域: 一块代码区域, 在编码时就确定了, 不会再变化
  * 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量
```
   var a = 10,

    b = 20;



function fn(x) {

    var a = 100, //与外层(上层)作用域中的a不冲突

        c = 300;

    function bar(x) {//与外层(上层)作用域中的a不冲突

        var a = 1000,

            d = 400;

    }



    bar(100);

    bar(200);

}

fn(10);
```
![b72c8529c846ae29bd537460c7de9b54.png](evernotecid://CEB7F35F-CF96-4521-B417-9D3060DC64F6/appyinxiangcom/25551795/ENResource/p23)

* 分类:
  * 全局
  * 函数
  * js没有块作用域(在ES6之前)
* 作用?
  * 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突
  * 作用域链: 查找变量
* 区别作用域与上下文环境
  * 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了
  * 上下文环境: 动态的, 执行代码时动态创建(对象), 当执行结束消失
  * 联系: 上下文环境是在对应的作用域中的
  ![e60db139657f456adfa0c7068dcecdbf.png](evernotecid://CEB7F35F-CF96-4521-B417-9D3060DC64F6/appyinxiangcom/25551795/ENResource/p21)
  
## 闭包 
* 理解:
  * 当嵌套的内部函数引用了外部函数的变量时就产生了闭包
  * 通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性
* 作用:
  * 延长局部变量的生命周期
  * 让函数外部能操作内部的局部变量
* 写一个闭包程序
  ```
  function fn1() {
    var a = 2;
    function fn2() {
      a++;
      console.log(a);
    }
    return fn2;
  }
  var f = fn1();
  f();
  f();
  ```
* 闭包应用:
  * 回调函数
  * 模块化编码: 封装一些数据以及操作数据的函数, 向外暴露一些行为
  * 循环遍历加监听
  * jQuery大量使用的闭包
* 缺点:
  * 变量占用内存的时间可能会过长
  * 可能导致内存泄露
  * 解决:
    * 及时释放 : f = null; //让内部函数对象成为垃圾对象
## 内存泄露与内存溢出
* 内存泄露
  * 定义: 不再需要的内存对象, 因为某种原因不能成为垃圾对象而一直不能被回收(占用内存)
  * 例如: 意外的全局变量, 定时器, 闭包...
  * 问题: 导致可用内存减小
  * 解决: 及时释放内存
* 内存溢出
  * 定义: 申请/需要的空间超过了剩余的最大空间, 程序就会抛出'内存溢出的错误
  * 例如: 不断创建对象/数组(大)
  * 问题: 运行出错, 程序停止
  * 解决: 减小申请内存, 及时释放内存
* 关系
  * 内存泄露如果不断累积, 就有可能导致内存溢出的错误
  ![ea159fffae994145e41016e06bd349d6.png](evernotecid://CEB7F35F-CF96-4521-B417-9D3060DC64F6/appyinxiangcom/25551795/ENResource/p20)
  
